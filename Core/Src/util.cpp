#include "util.h"
#include "defs.h"

//-----------------------------------------------------------------------------
//
// Local Definitions
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Local Datatypes
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Local Function Prototypes
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Local Function Definitions
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Interface Function Definitions
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

void util_memcpy(UINT8* dest, UINT8* src, UINT32 len){
  UINT32 i;
  UINT32 words;
  UINT32 alignment;

  // If both the source address and destination address are word aligned,
  // use fast copy method.
  // Check for dest and src to be aligned on the same offset from a word
  // boundary

  if (((UINT32)dest % 4) == ((UINT32)src % 4)) {
    // Copy bytes until we're aligned on a word boundary
    // Get byte alignment offset
    alignment = ((UINT32)(dest)) % 4;
    i = 0;
    while (i < alignment) {
      // Copy byte
      *dest = *src;
      // Increment i
      i++;
      // Decrement remaining length
      len--;
      // Increment destination address
      (UINT8*)dest++;
      (UINT8*)src++;
    }
    words = len / 4;
    len = len % 4;
  } else {
    words = 0; // src and dest are not byte aligned, use slow copy
  }

  // Copy remaining words
  for (i = 0; i < words; i++) {
    *(((UINT32*)dest + i)) = *(((UINT32*)src + i));
  }

  // Copy remaining bytes
  for (i = 0; i < len; i++) {
    *(dest + (words * 4) + i) = *(src + (words * 4) + i);
  }
  return;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

void util_memset(UINT8* dest, UINT8 val, UINT32 len) {
  UINT32 i;
  UINT32 words;
  UINT32 word;
  UINT8 alignment;

  // Pack the byte-sized val into a word for speed setting
  word = val | (val << 8) | (val << 16) | (val << 24);

  // Set bytes until we're aligned on a word boundary
  // Get byte alignment offset
  alignment = ((UINT32)(dest)) % 4;
  i = 0;
  while (i < alignment) {
    // Copy byte
    *dest = val;
    // Increment i
    i++;
    // Decrement remaining length
    len--;
    // Increment destination address
    (UINT8*)dest++;
  }

  words = len / 4;
  len = len % 4;

  // Copy words
  for (i = 0; i < words; i++) {
    *((UINT32*)(dest + i)) = word;
  }

  // Copy bytes
  for (i = 0; i < len; i++) {
    *(dest + (words * 4) + i) = val;
  }
  return;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

INT32 util_max(INT32 num1, INT32 num2){
  if (num1 >= num2) {
    return num1;
  } else {
    return num2;
  }

}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

INT32 util_min(INT32 num1, INT32 num2){
  if (num1 <= num2) {
    return num1;
  } else {
    return num2;
  }

}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

INT32 util_bound(INT32 num, INT32 min, INT32 max){
  if (num <= min) {
    return min;
  } else if (num >= max) {
    return max;
  } else {
    return num;
  }
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

INT32 util_abs( INT32 val )
{
  if (val < 0) {
    return -val;
  }
  else {
    return val;
  }
}




//------------------------------------------------------------------------------
// This will interpolate/extrapolate to find (x,y) on the line defined by
// points (x0,y0),(x1,y1)
//------------------------------------------------------------------------------

int util_linear(int x, int x0, int x1, int y0, int y1)
{
  int y;
  int d;



  if (x0 == x1)
  {
    return y0;
  }

  d = x1 - x0;

  y = (y1 - y0) * (x - x0);
  y = (y + (d>>1))/d;                   // round

  return (y + y0);
}





//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

UINT16 util_read_le16( UINT8 *p )
{
  UINT16 tmp;



  tmp =            (UINT16) p[1];
  tmp = (tmp<<8) | (UINT16) p[0];

  return tmp;
}






//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

UINT32 util_read_le32( UINT8 *p )
{
  UINT32 tmp;



  tmp =            (UINT32) p[3];
  tmp = (tmp<<8) | (UINT32) p[2];
  tmp = (tmp<<8) | (UINT32) p[1];
  tmp = (tmp<<8) | (UINT32) p[0];

  return tmp;
}






//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

void util_write_le16( UINT8 *p, UINT16 val )
{
  p[0] = (UINT8) ((val>>0 )&0x00FF);
  p[1] = (UINT8) ((val>>8 )&0x00FF);
}





//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

void util_write_le32( UINT8 *p, UINT32 val )
{
  p[0] = (UINT8) ((val>>0 )&0x000000FF);
  p[1] = (UINT8) ((val>>8 )&0x000000FF);
  p[2] = (UINT8) ((val>>16)&0x000000FF);
  p[3] = (UINT8) ((val>>24)&0x000000FF);
}





//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

UINT16 util_read_be16( UINT8 *p )
{
  UINT16 tmp;



  tmp =            (UINT16) p[0];
  tmp = (tmp<<8) | (UINT16) p[1];

  return tmp;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

UINT32 util_read_be24( UINT8 *p )
{
  UINT32 tmp;



  tmp =            (UINT32) p[0];
  tmp = (tmp<<8) | (UINT32) p[1];
  tmp = (tmp<<8) | (UINT32) p[2];
  

  return tmp;
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

UINT32 util_read_be32( UINT8 *p )
{
  UINT32 tmp;



  tmp =            (UINT32) p[0];
  tmp = (tmp<<8) | (UINT32) p[1];
  tmp = (tmp<<8) | (UINT32) p[2];
  tmp = (tmp<<8) | (UINT32) p[3];

  return tmp;
}






//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

void util_write_be16( UINT8 *p, UINT16 val )
{
  p[0] = (UINT8) ((val>>8 )&0x00FF);
  p[1] = (UINT8) ((val>>0 )&0x00FF);
}





//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

void util_write_be32( UINT8 *p, UINT32 val )
{
  p[0] = (UINT8) ((val>>24)&0x000000FF);
  p[1] = (UINT8) ((val>>16)&0x000000FF);
  p[2] = (UINT8) ((val>>8 )&0x000000FF);
  p[3] = (UINT8) ((val>>0 )&0x000000FF);
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

void util_write_be24( UINT8 *p, UINT32 val )
{
  p[0] = (UINT8) ((val>>16)&0x000000FF);
  p[1] = (UINT8) ((val>>8 )&0x000000FF);
  p[2] = (UINT8) ((val>>0 )&0x000000FF);
}



//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

void util_init( void ){

}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

void util_main( void ){

}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

UINT32 util_memcmp(UINT8* loc1, UINT8* loc2, UINT32 len) {
  UINT32 i;
  for (i = 0; i < len; i++) {
    if (*(loc1 + i) != *(loc2 + i)) {
      return 1; // Not a match
    }
  }
  return 0; // Memory is matched
}

